<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-media-query/iron-media-query.html">
<link rel="import" href="../paper-ripple/paper-ripple.html">
<link rel="import" href="../overlay-container/overlay-behavior.html">

<!--
  By default this element center the dropdown in the middle of the screen.
-->
<dom-module id="dropdown-menu">
  <template>
    <style>
      :host {
        @apply(--layout-vertical);
        @apply(--layout-center-center);
        bottom: 0;
        left: 0;
        margin: auto;
        position: fixed;
        right: 0;
        top: 0;
      }

      /* content box */
      #content {
        background: white;
        border-radius: 2px;
        box-shadow: 0 1px 20px 2px rgba(0, 0, 0, 0.2);
        min-width: 180px;
        position: absolute;
      }

      :host([small-screen]) #content {
        width: 80%;
        min-width: auto;
      }

      #content ::content button,
      #content ::content a {
        background: none;
        border: 0;
        color: initial;
        cursor: pointer;
        display: block;
        font-size: 16px;
        outline: 0;
        overflow: hidden;
        padding: 14px 20px 14px;
        position: relative;
        text-align: left;
        text-decoration: none;
        width: 100%;
      }
    </style>

    <div id="content">
      <content></content>
    </div>

    <iron-media-query query="(max-width: 640px)" query-matches="{{smallScreen}}"></iron-media-query>

  </template>
</dom-module>

<script>
(function() {
  'use strict'

  Polymer({

    is: 'dropdown-menu',

    properties: {

      noCancelOnOutsideClick: {
        type: Boolean,
        value: false
      },

      smallScreen: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },

      /**
       * The element that should be used to position the element. If not set, it will
       * be centered on the screen.
       * @type {!Element}
       */
      positionTarget: Object,

      // The element to fit `this` into.
      fitTarget: {
        type: Object,
        value: window
      }

    },

    behaviors: [
      OverlayBehavior
    ],

    listeners: {
      'tap': '_onTap',
      'overlay-opened': '_overlayOpened',
      'overlay-closed': '_overlayClosed'
    },

    _onTap(event) {
      event.preventDefault();
      event.stopPropagation();

      if (!this.noCancelOnOutsideClick && event.target.tagName === 'DROPDOWN-MENU') {
        this.opened = false;           
      }
    },

    _overlayOpened() {
      if (this.smallScreen || !this.positionTarget) {
        this.style.background = 'rgba(0,0,0, 0.6)';

        this._animation = this.animate([
          {opacity: 0}, 
          {opacity: 1}    
        ], {
          duration: 300,
          easing: 'cubic-bezier(0.165, 0.84, 0.44, 1)'
        });
      } else {
        this._positionize();

        this._animation = this.$.content.animate([
          {transform: 'scale(0.3, 0) translate(20px, -10px)'},
          {transform: 'scale(1, 1) translate(0, 0)'}     
        ], {
          duration: 240,
          easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
        });
      }

      this._animation.onfinish = _ => {
        this.fire('overlay-open-animation-finish');
        this.async(_ => this._ensureRipples());
        this._animation = null;
      };
    },

    _overlayClosed() {
      this.style.display = '';

      this._animation = this.animate([
        {opacity: 1}, 
        {opacity: 0}    
      ], {
        duration: 240,
        easing: 'cubic-bezier(0.645, 0.045, 0.355, 1)'
      });

      this._animation.onfinish = _ => {
        this.remove();

        Object.assign(this.$.content.style, {
          top: '',
          bottom: '',
          left: '',
          right: '',
          transformOrigin: ''
        });

        this.style.background = '';
      };
    },

    /**
     * Position the content div to the positionTarget.
     * top/right align have priority.
     */
    _positionize() {
      const rect = this.$.content.getBoundingClientRect();
      const fitRect = this._getNormalizedRect(this.fitTarget);
      const positionRect = this.positionTarget.getBoundingClientRect();

      let top, bottom, right, left, transformOrigin;

      if (fitRect.height - positionRect.bottom >= rect.height) {
        top = positionRect.top + 'px';
        transformOrigin = 'top';
      } else {
        bottom = 0 + 'px';
        transformOrigin = 'bottom';
      }

      if (positionRect.right >= rect.width) {
        right = fitRect.width - positionRect.right + 'px';
        transformOrigin += ' right';
      } else {
        left = positionRect.left + 'px';
        transformOrigin += ' left';
      }

      Object.assign(this.$.content.style,
        {top, bottom, right, left, transformOrigin});
    },

    _getNormalizedRect(target) {
      if (target === document.documentElement || target === window) {
        return {
          top: 0,
          left: 0,
          width: window.innerWidth,
          height: window.innerHeight,
          right: window.innerWidth,
          bottom: window.innerHeight
        };
      }
      return target.getBoundingClientRect();
    },

    /**
     * Lazy render the <paper-ripple> element into every button. 
     */
    _ensureRipples() {
      Polymer.dom(this).children.forEach(el => {
        if ((el.tagName === 'BUTTON' || el.tagName === 'A') && !el._hasRipple) {
          const ripple = this.create('paper-ripple', {
            opacityDecayVelocity: 0.8,
            recenters: true
          });

          Polymer.dom(el).appendChild(ripple);
          el._hasRipple = true;
        }
      });
    }

  });

}());
</script>
